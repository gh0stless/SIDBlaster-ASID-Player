HardSID_SoftFlush kann verwendet werden, um der hardsid.dll anzuzeigen, dass der Datenpuffer sofort in die Hardware geschrieben werden soll
(es sendet den Softwarepuffer an die Hardware) und dann den Softwarepuffer leert.
Es wird nur von ACID64 verwendet, um den SID-Sound stummzuschalten oder zu stoppen.
Zum Beispiel wird $00 in $d418 geschrieben, und dann wird HardSID_SoftFlush aufgerufen, um dies sofort wirksam zu machen.

HardSID_Flush wird verwendet, um den Hardwarepuffer zu leeren. Dies löscht jedoch nicht den Softwarepuffer.

Du musst Zyklusinformationen für deine Schreibvorgänge an den SID bereitstellen, um die Schreibvorgänge genau zu machen.
Für USB-Hardware wird ein Softwarepuffer verwendet, um die Latenz der USB-Schnittstelle zu optimieren.

Du kannst entscheiden, alle 20 Millisekunden an die Hardware für deinen Synthesizer zu schreiben und alle Schreibvorgänge für diesen Zeitraum zu sammeln,
und zum Beispiel 8 Zyklen zwischen den Schreibvorgängen haben.
Der letzte Schreibvorgang des Zeitraums sollte die verbleibenden Zyklen dieser 20 Millisekunden angeben.

Zum Beispiel hast du 3 Schreibvorgänge für diesen Zeitraum:


FRAME_IN_CYCLES = 17734475 / 18 / 50;   // 50Hz in Zyklen für PAL-Takt
cycles = 0;

HardSID_Try_Write(0, cycles, 0x04, $41);

cycles += 8;

HardSID_Try_Write(0, cycles, 0x0b, $41);

cycles += 8;

HardSID_Try_Write(0, FRAME_IN_CYCLES - cycles, 0x12, $41);

Die obigen Schreibvorgänge schreiben auf Gerät 0. Der erste Schreibvorgang schreibt in Register 4, der zweite in Register 11
und der letzte in Register 18. Der letzte Schreibvorgang stellt sicher, dass der nächste Zeitraum 20 Millisekunden später beginnt.
Stelle sicher, dass du die Methode HardSID_Try_Write verwendest und den Rückgabewert überprüfst,
um festzustellen, ob der Software- oder Hardwarepuffer voll ist.
Wenn dies der Fall ist, musst du ein paar Millisekunden warten und es erneut versuchen.
Du musst sicherstellen, dass der Puffer immer gefüllt ist, damit das Timing immer korrekt ist.
Wenn du für einen Zeitraum nichts zu schreiben hast, dann mache einfach Folgendes:

HardSID_Try_Write(0, FRAME_IN_CYCLES, 0x1e, 0);

Dies wird 0 in das SID-Register $1E schreiben, was nichts bewirkt.

Wenn du einfach zu einem beliebigen Zeitpunkt in den SID schreiben möchtest,
gib einfach 0 als Zyklusparameter an, dann wird der Schreibvorgang sofort eingeplant.
Das exakt zyklische Timing ist hauptsächlich notwendig, weil C64-Musikplayer die verschiedenen SID-„Bugs“ auf sehr spezifische Weise handhaben.
Zum Beispiel: Wenn du nicht vorsichtig bist, wenn du in die Gate- und ADSR-Register schreibst, kann es sein, dass du keinen Ton erhältst.
Google „sid adsr“ für weitere Informationen.

– Stein

Du kannst eine globale Variable verwenden, um eine Instanzanzahl zu speichern.
Überprüfe dies in deiner object_new-Funktion, und wenn sie zu hoch ist, gib null zurück (und idealerweise eine Fehlermeldung in der Konsole aus),
um anzuzeigen, dass die Objekterstellung fehlgeschlagen ist.
Andernfalls erhöhe die Anzahl und verringere sie in der object_free-Funktion.
